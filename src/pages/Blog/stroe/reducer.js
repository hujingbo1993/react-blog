import * as constants from './constants';

const defaultState = {
  blogList: [
    {
      id: 0,
      title: '算法到底难在哪',
      content:
        '\n>年轻人，在数学中你不理解事情，你只是习惯它们。——约翰·冯·诺伊曼\n\n其实最初我看到上面那句话的时候非常的不理解，也曾经相信过另一种解释那就是所谓的“以你的智商无法和你解释”，但当我认真的考虑算法和数学到底难在哪的时候，这句话和一本书《技术的本质》从无尽的迷惑当中拯救了我，让我从思中回到了练中。\n\n\n>算法（algorithm），在数学（算学）和计算机科学之中，为任何良定义的具体计算步骤的一个序列，常用于计算、数据处理和自动推理。精确而言，算法是一个表示为有限长列表的有效方法。算法应包含清晰定义的指令用于计算函数]。\n\n算法到底是什么，**法**这个词，同时上学时如类似分而治之的**思想**，递归的**思想**之类的描述一度迷惑了我，让我认为算法是可以通过某种思想自然而然产生，而对算法感到迷惑则是因为对其思想掌握的不到位，显然，在这种思而不练的思路下，一点没少费时间，但我对算法的认识始终处于一种比较模糊的状态，在大四人生的第一次面试时还傻乎乎的认为讲所谓的思路比写实现更加的接近本质，当然那是一次失败的面试，隔了这么久再次回想算法时，发现将其放在《技术的本质》一书对技术的分析框架下一切都变的清晰了许多。\n\n《技术的本质》一书中对技术有这杨一种描述。\n\n>从本质上看，技术是被捕获并加以利用的现象的集合，或者说，技术是对现象有目的的**编程**。\n>\n>技术是为了让我们能够达成某种目的而进行的现象的“**合奏**”。\n\n这样的描述下算法就清晰起来了，这也是一切教学中都强调编程和算法学习的实践性的来源，其实践培养出的人对计算机计算过程的直觉性，大脑对过程的“捕获”才是数学及算法学习进步的原因，与其说算法是难的，不如说算法是繁杂的，因为算法这个技术服务的目的系统是计算机，而面对繁杂事务的解药就是模块化和抽象。前者在现实世界就是各种库，而后者就是类似算法复杂度这样的思维辅助工具。\n\n总结一下，想要通过理解算法而掌握算法是一条死路，练习才是正道，而练习也是有选择的，我们要通过练习达成对计算机这个抽象层面上的一些“现象”的直觉捕捉，而剩下的其实更多的是分析目的，应用“现象”达成“合奏”，更多更繁复的算法的记忆和其他知识系统学会了进阶知识后的效果不一样，他们之间并没有上下的层级关系而是一条流水线的长度的区别，处理繁杂更依赖的是抽象和模块化的能力而不是更多的算法知识本身，这也是算法练习能长久的提高编程能力但“算法能力”会随着时间渐渐消失的原因之一。',
    },
    {
      id: 1,
      title: 'css html 跨越协同障碍，微精通的应用',
      content:
        '\n刚开始从编程的世界转向 css 和 html 的世界时其实充满了不适，大家也有非常多的吐槽，但显然 css 和 html 并不是在所有人那里都是让人不适而难受的，有人享受着这种过程尤其是 css 的部分，虽然面对一些赏心悦目的作品我总有强烈的为什么要将简单问题复杂化的吐槽冲动而欣赏和学习不能，但最近看的一本书让我开始有些理解我对 css 和 html 感到难受的来源以及那些能很好的掌握这门技艺的人的方法。\n\n这本书叫做《微精通》，封面上写着的几点和中间一个关键的概念串联起来可能就是问题的答案。\n\n微精通是一本讲怎样快速习得技能的书籍，这当然很常见，但其与很多学习强调整体性不同的一点就在于它提供了如何面对一个大技能下面的小技能之间协同障碍的一种解决方案，而无论是从三件套不同思路的切换，还是 css 资深规则的复杂性，其本质来源都是技能之间互相妨碍的结果。\n\n那么解决方案是什么呢，虽然要根据技能的特性自己的寻找，但一些大的原则和抽象的方式都是非常令人受益且非常适合前端的，比如 css 的练习就天然的符合**可复验**，**可实验**有**即时回报**等等的特点，意识到妨碍的存在并且有意识的分配不同权重的注意力在各项小技能上也是非常好的减少大脑熵值的方式，心态方面书中有通过视觉想象寻找自信点，中心点，平衡性小技巧，而 css 显然天然的适合这种方式，等等等等。\n\n>发掘兴趣+识别重心+立体学习+内行经验=无限潜能\n\n这是书封面上的一行字，让我完美的想起了我曾经非常难以接受的张鑫旭老师在慕课网上开设的几门 css 课程，并发现张老师的课程简直完美符合这个流程，张老师会把知识拟人化的讲述，通过他个人兴趣的想象中的魔法世界来描述问题，然后每节课都会用一个概念来串联整个知识点，并且过程中会用各种比喻，而且 css 还天然的依靠着整个排版经验体系，相信如果不是因为兴趣不同导致的劝退我可能会早的多的结束对 css 厌烦的感觉，繁杂的事物自有其处理方式。\n\n总结一下就是虽然我们学习总是强调整体性，但整个学习过程中不可避免的存在长期的分裂而且互相影响的一些技能体系，如何与它们友好相处度过这个阶段是通向技能进阶的一条正道，虽然我还并没有太得要领但感觉已经好多了，也与未来的自己和大家共勉。',
    },
    {
      id: 2,
      title: 'ajax带来的思考，如何以专业名词为引构背后相对完整的知识体系',
      content:
        '>AJAX 即“Asynchronous JavaScript and XML”（异步的 JavaScript 与 XML 技术），指的是一套综合了多项技术的浏览器端网页开发技术。\n\n这是摘自维基百科的一个定义，也是当年我始终无法从名字直观感受到作用的一个技术名词之一，过了一年多各种其他知识的训练后，因为决定以前端谋生再回头看这个词汇时，一个通用的原因和解决方案在我脑海中浮现出来，这里总结一下希望可以帮助到和当年的我一样非常依赖名称构建知识但对很多名称始终无法找到感觉只能死记硬背的同学们。\n\n要谈这个问题要先后退一步谈谈整个专业词汇的作用到底是什么，简单来讲我个人一直有一个误区就是对名称过于重视**抽象性**而忽视了其**工具性**，在普通的沟通中可能这两样的区分还不是那么明显，但在特别工具化的专业词汇中工具性压倒抽象性这种很常见的现象一直被我视而不见，“就这么叫了”“名字没起好”“历史遗留问题”这类陈词滥调的解释虽然能解一时之惑但终究是一种逃避性的回答，直面问题的话其实理由很简单，那就是作为提高专业人士沟通效率存在的专业词汇在一些常用“技术域”形成的**各种阶段**都可能开始传播，因为高频使用成为某种共识而后固定，而不同阶段的名称都带有其阶段性特征。\n\n这里可以简单的根据技术演进的一般规律将这个过程分为三个阶段，我称之为**为何物**演进（whw），就是why->how->what，也就是常见的遇到什么问题，如何解决，具体实现，越在左边的阶段形成的称呼越抽象，右边的越具体，作为学习的入口，显然在左边的比较容易让人产生直觉性的理解，但如果要灵活的掌握一门技术，这三个阶段的内容都是缺一不可的所以本质上从哪里着手不会影响什么，而且按照这个结构固化下来的知识会非常的符合直觉。\n\n具体用为何物来理解 ajax 和一切稍微偏具体的词汇时都可以通过非常简单的一个流程来解决，那就是先确认其演进的位置，像 ajax 几乎就是在直接描述这个技术诞生之初的具体实现了，然后缺什么补什么用自己的话把前两者补全，而且为什么的部分其历史故事当然可以去寻找但并不一定强求最原始的那个版本，因为我们这套流程的最终目的是建立完备的因其**直觉性**而可以灵活运用的知识体系，如果对历史故事没有感觉或者找不到的话完全可以用自己的经历来填充这个部分，然后怎么做的部分就更是如此，依据个人经验的类比要常用，可以粗糙一点抽象一点不要执着于精确的描述出一个静态的已知实现，最后的部分从这个名字现在代表的东西与其的东西不同也能理解前一步为什么要不执着，而且这一步也一样不用过于执着，对具体实现的熟悉应该也只可能是常接触的副产品，非抽象和理论的部分强行去学即难也用处不大。\n\n简单的总结一下就是面对一个名字，先摸位置留空，然后用直觉经验填空，当然直觉经验有其局限性，但高速的认知过程可以帮助人更快更有**行动力**和**自信**的开始实践从而进入**正循环**而不是因为某种畏惧之心成为无意识的搬运工，与未来的自己和大家共勉。',
    },
    {
      id: 3,
      title: '领域驱动设计阅读笔记',
      content:
        '* 模型是一种简化，是通过把与解决问题密切相关的方面抽象出来忽略无关细节的一种对现实的解释方式。\n\n* 软件的目的领域常常与计算机关系不大，除了服务于软件本身的软件。\n\n* 模型是一种解决信息超载的工具。\n\n* 建模相对于对现实的模拟更接近于制作电影，出于某种目的概括的反应现实。\n\n* 软件的核心在于为用户解决领域相关的问题。\n\n模型的创建\n\n*     与实现绑定\n*     产生了一套一致的蕴含知识的模型\n*     不断根据实际情况进行提炼\n\n* 知识消化是一种探索，永远追求更好的，不要追求最好的。\n\n* 语言是一种本能，能够处理非常大的复杂性，所以通过建立一套更精确的对于特定领域的语汇来处理复杂性是可行的。\n\n* 设计的细节应该体现在代码而不是设计图当中。\n\n* 模型不是图，图只是帮助表达和解释的一种工具。\n\n* 消除歧义是声明式设计的最大优点。\n\n* 像数学一样，一个能够精确表达超长概念的语言最重要的部分就是严格一致性。\n\n* 软件的难度，每个人都在做 设计。\n\n* 分层是作为一种隐喻的强力工具，原则是层中的任何元素仅依赖本层的其他元素或者下层元素，向上的通信必须通过间接的传递机制进行。\n\n* 界面层 显示信息和解释指令\n* 应用层 定义任务，只会领域对象解决问题，要简单，不包含领域知识，主要进行任务调配\n* 领域层（模型）保存业务规则\n* 基础设施 提供通用能力，如持久化，基本的绘图，架构框架。\n\n* 框架的连接方式目的是维护领域层的独立性。\n\n* 建立适当的领域模型，最大化框架的价值而不是被框架的侵入性所绑架。\n\n* smart UI \n* 在用户界面实现业务规则，将程序分成小的功能模块，用共享数据库连接数据，高自动化。\n\n* 关系的精度要根据领域有足够高的精度。这体现了更深入的理解。\n\n* 当一个对象通过其标识而不是属性区分时，这个类的定义应该聚焦于生命周期的连续性。\n\n* value object  对于只需要表达是什么而不需要表达是谁的元素并不需要标识，常常是临时对象，需要时创建，然后被丢弃，如颜色数字信息等等，通常应该是不可变的，整体的。\n\n* 不变可以确保两种优化策略共享或者复制后的安全性。\n\n* module/package 处理认知超载，脑内工程的辅助设备，是一种表达机制。\n\n过于细致的打包方案会产生两个代价：\n*     代码无法清晰表示模型\n*     人类把划分后的东西还原的能力有限，如果框架下需要过多的考虑这部分的话非常消耗脑力。\n\n* 领域建模反应真实世界，因为真实世界就少有清晰的边界，所以对象的关联常常十分复杂。',
    },
  ],
};

export default (state = defaultState, action) => {
  switch (action.type) {
    case constants.CHANGE_DETAIL:
      return {
        blogList: action.data,
      };
    default:
      return state;
  }
};
